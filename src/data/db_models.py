"""SQLAlchemy ORM models for database storage."""

from datetime import date, datetime
from enum import Enum
from typing import Optional

from sqlalchemy import (
    DateTime,
    Float,
    ForeignKey,
    Index,
    Integer,
    String,
    UniqueConstraint,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


class Base(DeclarativeBase):
    """Base class for all SQLAlchemy models."""

    pass


class SignalDirection(str, Enum):
    """Trading signal direction."""

    LONG = "LONG"
    SHORT = "SHORT"


class SignalStatus(str, Enum):
    """Signal status."""

    PENDING = "PENDING"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    EXPIRED = "EXPIRED"


class TradeStatus(str, Enum):
    """Trade status."""

    OPEN = "OPEN"
    CLOSED = "CLOSED"
    STOPPED = "STOPPED"


class Stock(Base):
    """Stock metadata and reference data."""

    __tablename__ = "stocks"

    symbol: Mapped[str] = mapped_column(String(20), primary_key=True)
    name: Mapped[str] = mapped_column(String(255))
    sector: Mapped[str | None] = mapped_column(String(100), nullable=True)
    industry: Mapped[str | None] = mapped_column(String(100), nullable=True)
    market_cap: Mapped[float | None] = mapped_column(Float, nullable=True)
    avg_volume: Mapped[int | None] = mapped_column(Integer, nullable=True)
    last_updated: Mapped[datetime] = mapped_column(
        DateTime, default=datetime.utcnow, onupdate=datetime.utcnow
    )

    # Relationships
    daily_bars: Mapped[list["DailyBar"]] = relationship(
        "DailyBar", back_populates="stock", cascade="all, delete-orphan"
    )
    signals: Mapped[list["Signal"]] = relationship(
        "Signal", back_populates="stock", cascade="all, delete-orphan"
    )
    trades: Mapped[list["Trade"]] = relationship(
        "Trade", back_populates="stock", cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Stock(symbol='{self.symbol}', name='{self.name}')>"


class DailyBar(Base):
    """Daily OHLCV price data."""

    __tablename__ = "daily_bars"
    __table_args__ = (
        UniqueConstraint("symbol", "date", name="uq_daily_bar_symbol_date"),
        Index("ix_daily_bars_symbol_date", "symbol", "date"),
    )

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    symbol: Mapped[str] = mapped_column(
        String(20), ForeignKey("stocks.symbol", ondelete="CASCADE"), index=True
    )
    date: Mapped[date] = mapped_column(DateTime, index=True)
    open: Mapped[float] = mapped_column(Float)
    high: Mapped[float] = mapped_column(Float)
    low: Mapped[float] = mapped_column(Float)
    close: Mapped[float] = mapped_column(Float)
    volume: Mapped[int] = mapped_column(Integer)
    adjusted_close: Mapped[float] = mapped_column(Float)

    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="daily_bars")

    def __repr__(self) -> str:
        return f"<DailyBar(symbol='{self.symbol}', date='{self.date}', close={self.close})>"


class Signal(Base):
    """Trading signals generated by strategies."""

    __tablename__ = "signals"
    __table_args__ = (Index("ix_signals_symbol_status", "symbol", "status"),)

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    symbol: Mapped[str] = mapped_column(
        String(20), ForeignKey("stocks.symbol", ondelete="CASCADE"), index=True
    )
    strategy: Mapped[str] = mapped_column(String(100))
    direction: Mapped[str] = mapped_column(String(10))  # LONG/SHORT
    score: Mapped[int] = mapped_column(Integer)  # 0-100 signal strength
    entry_price: Mapped[float] = mapped_column(Float)
    stop_price: Mapped[float] = mapped_column(Float)
    target_price: Mapped[float] = mapped_column(Float)
    position_size: Mapped[float] = mapped_column(Float)  # Dollar amount or shares
    created_at: Mapped[datetime] = mapped_column(
        DateTime, default=datetime.utcnow, insert_default=datetime.utcnow
    )
    status: Mapped[str] = mapped_column(
        String(20), default=SignalStatus.PENDING.value, insert_default=SignalStatus.PENDING.value
    )  # PENDING/FILLED/CANCELLED/EXPIRED
    expires_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    notes: Mapped[str | None] = mapped_column(String(500), nullable=True)

    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="signals")
    trades: Mapped[list["Trade"]] = relationship(
        "Trade", back_populates="signal", cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Signal(id={self.id}, symbol='{self.symbol}', direction='{self.direction}', status='{self.status}')>"

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio."""
        if self.direction == SignalDirection.LONG.value:
            risk = self.entry_price - self.stop_price
            reward = self.target_price - self.entry_price
        else:
            risk = self.stop_price - self.entry_price
            reward = self.entry_price - self.target_price

        if risk <= 0:
            return 0.0
        return reward / risk


class Trade(Base):
    """Executed trades from signals."""

    __tablename__ = "trades"
    __table_args__ = (Index("ix_trades_symbol_status", "symbol", "status"),)

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    signal_id: Mapped[int | None] = mapped_column(
        Integer, ForeignKey("signals.id", ondelete="SET NULL"), nullable=True
    )
    symbol: Mapped[str] = mapped_column(
        String(20), ForeignKey("stocks.symbol", ondelete="CASCADE"), index=True
    )
    direction: Mapped[str] = mapped_column(String(10))  # LONG/SHORT
    entry_price: Mapped[float] = mapped_column(Float)
    entry_time: Mapped[datetime] = mapped_column(DateTime)
    exit_price: Mapped[float | None] = mapped_column(Float, nullable=True)
    exit_time: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    quantity: Mapped[int] = mapped_column(Integer)
    stop_price: Mapped[float | None] = mapped_column(Float, nullable=True)
    target_price: Mapped[float | None] = mapped_column(Float, nullable=True)
    pnl: Mapped[float | None] = mapped_column(Float, nullable=True)
    pnl_pct: Mapped[float | None] = mapped_column(Float, nullable=True)
    r_multiple: Mapped[float | None] = mapped_column(Float, nullable=True)
    status: Mapped[str] = mapped_column(
        String(20), default=TradeStatus.OPEN.value
    )  # OPEN/CLOSED/STOPPED
    notes: Mapped[str | None] = mapped_column(String(500), nullable=True)

    # Relationships
    signal: Mapped[Optional["Signal"]] = relationship("Signal", back_populates="trades")
    stock: Mapped["Stock"] = relationship("Stock", back_populates="trades")

    def __repr__(self) -> str:
        return (
            f"<Trade(id={self.id}, symbol='{self.symbol}', status='{self.status}', pnl={self.pnl})>"
        )

    def calculate_pnl(self) -> None:
        """Calculate PnL metrics when trade is closed."""
        if self.exit_price is None:
            return

        if self.direction == SignalDirection.LONG.value:
            self.pnl = (self.exit_price - self.entry_price) * self.quantity
            self.pnl_pct = (self.exit_price - self.entry_price) / self.entry_price
        else:
            self.pnl = (self.entry_price - self.exit_price) * self.quantity
            self.pnl_pct = (self.entry_price - self.exit_price) / self.entry_price

        # Calculate R-multiple if stop price is set
        if self.stop_price is not None:
            if self.direction == SignalDirection.LONG.value:
                risk_per_share = self.entry_price - self.stop_price
            else:
                risk_per_share = self.stop_price - self.entry_price

            if risk_per_share > 0:
                pnl_per_share = self.pnl / self.quantity
                self.r_multiple = pnl_per_share / risk_per_share


class PortfolioSnapshot(Base):
    """Point-in-time portfolio state snapshots."""

    __tablename__ = "portfolio_snapshots"
    __table_args__ = (Index("ix_portfolio_snapshots_timestamp", "timestamp"),)

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    timestamp: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    equity: Mapped[float] = mapped_column(Float)  # Total portfolio value
    cash: Mapped[float] = mapped_column(Float)  # Available cash
    open_positions: Mapped[int] = mapped_column(Integer)  # Number of open positions
    daily_pnl: Mapped[float] = mapped_column(Float)  # Day's profit/loss
    total_pnl: Mapped[float] = mapped_column(Float, default=0.0)  # Cumulative P&L
    drawdown_pct: Mapped[float] = mapped_column(Float)  # Current drawdown percentage
    high_water_mark: Mapped[float] = mapped_column(Float)  # Peak equity value

    def __repr__(self) -> str:
        return f"<PortfolioSnapshot(timestamp='{self.timestamp}', equity={self.equity}, drawdown={self.drawdown_pct:.2%})>"
