"""Strategy base class and core interfaces."""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal

if TYPE_CHECKING:
    import pandas as pd


class Direction(str, Enum):
    """Trade direction."""

    LONG = "LONG"
    SHORT = "SHORT"


class ExitType(str, Enum):
    """Type of exit signal."""

    STOP_LOSS = "STOP_LOSS"
    TAKE_PROFIT = "TAKE_PROFIT"
    TRAILING_STOP = "TRAILING_STOP"
    STRATEGY_EXIT = "STRATEGY_EXIT"
    TIME_EXIT = "TIME_EXIT"


@dataclass
class Signal:
    """Represents a trading signal generated by a strategy.

    Attributes:
        symbol: Stock ticker symbol
        strategy: Name of the strategy that generated the signal
        direction: Trade direction (LONG or SHORT)
        entry_price: Suggested entry price
        stop_loss: Stop loss price level
        take_profit: Take profit price level
        score: Signal strength score (0-100)
        reasoning: Human-readable explanation of the signal
        timestamp: When the signal was generated
        metadata: Additional strategy-specific data
    """

    symbol: str
    strategy: str
    direction: Literal["LONG", "SHORT"]
    entry_price: float
    stop_loss: float
    take_profit: float
    score: int
    reasoning: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate signal parameters."""
        if not 0 <= self.score <= 100:
            raise ValueError("Score must be between 0 and 100")

        if self.entry_price <= 0:
            raise ValueError("Entry price must be positive")

        if self.stop_loss <= 0:
            raise ValueError("Stop loss must be positive")

        if self.take_profit <= 0:
            raise ValueError("Take profit must be positive")

        # Validate stop loss and take profit relative to direction
        if self.direction == "LONG":
            if self.stop_loss >= self.entry_price:
                raise ValueError("Stop loss must be below entry price for LONG")
            if self.take_profit <= self.entry_price:
                raise ValueError("Take profit must be above entry price for LONG")
        else:  # SHORT
            if self.stop_loss <= self.entry_price:
                raise ValueError("Stop loss must be above entry price for SHORT")
            if self.take_profit >= self.entry_price:
                raise ValueError("Take profit must be below entry price for SHORT")

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk-reward ratio.

        Returns:
            Ratio of potential reward to potential risk
        """
        if self.direction == "LONG":
            risk = self.entry_price - self.stop_loss
            reward = self.take_profit - self.entry_price
        else:
            risk = self.stop_loss - self.entry_price
            reward = self.entry_price - self.take_profit

        if risk <= 0:
            return 0.0

        return reward / risk

    @property
    def risk_percent(self) -> float:
        """Calculate distance to stop loss as percentage.

        Returns:
            Risk as percentage of entry price
        """
        if self.direction == "LONG":
            return ((self.entry_price - self.stop_loss) / self.entry_price) * 100
        else:
            return ((self.stop_loss - self.entry_price) / self.entry_price) * 100

    @property
    def reward_percent(self) -> float:
        """Calculate distance to take profit as percentage.

        Returns:
            Potential reward as percentage of entry price
        """
        if self.direction == "LONG":
            return ((self.take_profit - self.entry_price) / self.entry_price) * 100
        else:
            return ((self.entry_price - self.take_profit) / self.entry_price) * 100

    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary.

        Returns:
            Dictionary representation of the signal
        """
        return {
            "symbol": self.symbol,
            "strategy": self.strategy,
            "direction": self.direction,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "score": self.score,
            "reasoning": self.reasoning,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata,
            "risk_reward_ratio": self.risk_reward_ratio,
            "risk_percent": self.risk_percent,
            "reward_percent": self.reward_percent,
        }


@dataclass
class ExitSignal:
    """Represents an exit signal for an open trade.

    Attributes:
        trade_id: ID of the trade to exit
        exit_type: Type of exit (stop loss, take profit, etc.)
        exit_price: Suggested exit price
        reasoning: Human-readable explanation of the exit
        timestamp: When the exit signal was generated
    """

    trade_id: int
    exit_type: Literal["STOP_LOSS", "TAKE_PROFIT", "TRAILING_STOP", "STRATEGY_EXIT", "TIME_EXIT"]
    exit_price: float
    reasoning: str
    timestamp: datetime = field(default_factory=datetime.now)

    def __post_init__(self) -> None:
        """Validate exit signal parameters."""
        if self.exit_price <= 0:
            raise ValueError("Exit price must be positive")

    def to_dict(self) -> dict[str, Any]:
        """Convert exit signal to dictionary.

        Returns:
            Dictionary representation of the exit signal
        """
        return {
            "trade_id": self.trade_id,
            "exit_type": self.exit_type,
            "exit_price": self.exit_price,
            "reasoning": self.reasoning,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class StrategyResult:
    """Result of scanning multiple stocks with a strategy.

    Attributes:
        strategy_name: Name of the strategy used
        signals: List of generated signals
        scanned_count: Number of stocks scanned
        signal_count: Number of signals generated
        scan_time_ms: Time taken to scan in milliseconds
    """

    strategy_name: str
    signals: list[Signal] = field(default_factory=list)
    scanned_count: int = 0
    signal_count: int = 0
    scan_time_ms: float = 0.0

    def __post_init__(self) -> None:
        """Validate and update signal count."""
        if self.signal_count == 0 and self.signals:
            self.signal_count = len(self.signals)

    @property
    def hit_rate(self) -> float:
        """Calculate percentage of stocks that generated signals.

        Returns:
            Hit rate as percentage (0-100)
        """
        if self.scanned_count == 0:
            return 0.0
        return (self.signal_count / self.scanned_count) * 100

    @property
    def avg_score(self) -> float:
        """Calculate average signal score.

        Returns:
            Average score of all signals
        """
        if not self.signals:
            return 0.0
        return sum(s.score for s in self.signals) / len(self.signals)

    def get_top_signals(self, n: int = 10) -> list[Signal]:
        """Get top N signals sorted by score.

        Args:
            n: Number of signals to return

        Returns:
            List of top signals sorted by score descending
        """
        return sorted(self.signals, key=lambda s: s.score, reverse=True)[:n]

    def filter_by_direction(self, direction: Literal["LONG", "SHORT"]) -> list[Signal]:
        """Filter signals by direction.

        Args:
            direction: Trade direction to filter by

        Returns:
            List of signals matching the direction
        """
        return [s for s in self.signals if s.direction == direction]


@dataclass
class StrategyParameters:
    """Container for strategy parameters with validation.

    Attributes:
        name: Parameter name
        value: Current value
        min_value: Minimum allowed value
        max_value: Maximum allowed value
        description: Parameter description
    """

    name: str
    value: float | int | bool | str
    min_value: float | int | None = None
    max_value: float | int | None = None
    description: str = ""

    def validate(self) -> bool:
        """Validate that value is within bounds.

        Returns:
            True if valid, False otherwise
        """
        if isinstance(self.value, bool | str):
            return True

        if self.min_value is not None and self.value < self.min_value:
            return False

        return not (self.max_value is not None and self.value > self.max_value)


class Strategy(ABC):
    """Abstract base class for all trading strategies.

    All strategies must implement the scan, check_exit, get_parameters,
    and set_parameters methods. This ensures a consistent interface
    for the trading system.

    Attributes:
        name: Strategy name
        description: Strategy description
    """

    name: str = "BaseStrategy"
    description: str = "Base strategy class"

    @abstractmethod
    def scan(self, df: pd.DataFrame) -> Signal | None:
        """Scan a single stock for entry signal.

        Args:
            df: DataFrame with OHLCV data and indicators

        Returns:
            Signal if entry conditions are met, None otherwise
        """

    @abstractmethod
    def check_exit(self, df: pd.DataFrame, trade: Any) -> ExitSignal | None:
        """Check if an open trade should be exited.

        Args:
            df: DataFrame with current OHLCV data and indicators
            trade: The open trade to check

        Returns:
            ExitSignal if exit conditions are met, None otherwise
        """

    @abstractmethod
    def get_parameters(self) -> dict[str, Any]:
        """Return current parameter values.

        Returns:
            Dictionary of parameter names to values
        """

    @abstractmethod
    def set_parameters(self, params: dict[str, Any]) -> None:
        """Update strategy parameters.

        Args:
            params: Dictionary of parameter names to new values
        """

    def validate_dataframe(self, df: pd.DataFrame) -> bool:
        """Validate that DataFrame has required columns.

        Args:
            df: DataFrame to validate

        Returns:
            True if valid, False otherwise
        """
        required = {"open", "high", "low", "close", "volume"}
        df_columns = {col.lower() for col in df.columns}
        return required.issubset(df_columns)

    def calculate_stop_loss(
        self,
        entry_price: float,
        atr: float,
        direction: Literal["LONG", "SHORT"],
        multiplier: float = 2.0,
    ) -> float:
        """Calculate stop loss based on ATR.

        Args:
            entry_price: Entry price for the trade
            atr: Average True Range value
            direction: Trade direction
            multiplier: ATR multiplier for stop distance

        Returns:
            Stop loss price
        """
        if direction == "LONG":
            return entry_price - (atr * multiplier)
        else:
            return entry_price + (atr * multiplier)

    def calculate_take_profit(
        self,
        entry_price: float,
        stop_loss: float,
        direction: Literal["LONG", "SHORT"],
        risk_reward: float = 2.0,
    ) -> float:
        """Calculate take profit based on risk-reward ratio.

        Args:
            entry_price: Entry price for the trade
            stop_loss: Stop loss price
            direction: Trade direction
            risk_reward: Desired risk-reward ratio

        Returns:
            Take profit price
        """
        if direction == "LONG":
            risk = entry_price - stop_loss
            return entry_price + (risk * risk_reward)
        else:
            risk = stop_loss - entry_price
            return entry_price - (risk * risk_reward)

    def score_signal(
        self,
        trend_aligned: bool,
        momentum_aligned: bool,
        volume_confirmed: bool,
        at_support_resistance: bool,
        risk_reward_good: bool,
    ) -> int:
        """Calculate signal score based on multiple factors.

        Args:
            trend_aligned: Is trade in direction of trend?
            momentum_aligned: Is momentum supporting the trade?
            volume_confirmed: Is volume confirming the move?
            at_support_resistance: Is price at key level?
            risk_reward_good: Is risk-reward ratio acceptable?

        Returns:
            Score from 0-100
        """
        score = 0

        # Weight each factor
        if trend_aligned:
            score += 30
        if momentum_aligned:
            score += 25
        if volume_confirmed:
            score += 20
        if at_support_resistance:
            score += 15
        if risk_reward_good:
            score += 10

        return min(score, 100)


class StrategyRegistry:
    """Registry for managing available strategies.

    Provides a centralized way to register, retrieve, and list
    trading strategies.
    """

    def __init__(self) -> None:
        """Initialize empty registry."""
        self._strategies: dict[str, type[Strategy]] = {}

    def register(self, strategy_class: type[Strategy]) -> None:
        """Register a strategy class.

        Args:
            strategy_class: Strategy class to register
        """
        name = strategy_class.name
        self._strategies[name] = strategy_class

    def get(self, name: str) -> type[Strategy] | None:
        """Get a strategy class by name.

        Args:
            name: Strategy name

        Returns:
            Strategy class if found, None otherwise
        """
        return self._strategies.get(name)

    def list_strategies(self) -> list[str]:
        """List all registered strategy names.

        Returns:
            List of strategy names
        """
        return list(self._strategies.keys())

    def create_instance(self, name: str, **kwargs: Any) -> Strategy | None:
        """Create an instance of a registered strategy.

        Args:
            name: Strategy name
            **kwargs: Arguments to pass to strategy constructor

        Returns:
            Strategy instance if found, None otherwise
        """
        strategy_class = self.get(name)
        if strategy_class is None:
            return None
        return strategy_class(**kwargs)


# Global strategy registry
strategy_registry = StrategyRegistry()
